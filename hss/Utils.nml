/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
exception Error : (string, Lexer.pos);

// "-webkit-user-select" => ("user-select","-webkit-")
function vendor_prefix(s: string) {
	if String.get(s, 0) == '-' then {
		var len = String.length s;
		if      len > 8 && String.sub(s, 0, 8) == "-webkit-" then
			(String.sub(s, 8, len - 8), "-webkit-")
		else if len > 5 && String.sub(s, 0, 5) == "-moz-" then
			(String.sub(s, 5, len - 5), "-moz-")
		else if len > 4 && String.sub(s, 0, 4) == "-ms-" then
			(String.sub(s, 4, len - 4), "-ms-")
		else if len > 3 && String.sub(s, 0, 3) == "-o-" then
			(String.sub(s, 3, len - 3), "-o-")
		else
			(s, "")
	} else
		(s, "")
}

// #99AABB => (0x99, 0xAA, 0xBB)
function ofhex(h: string, p: Lexer.pos) {
	match String.length h {
	| 3 ->
		var r = int ("0x" + String.sub h 0 1);
		var g = int ("0x" + String.sub h 1 1);
		var b = int ("0x" + String.sub h 2 1);
		(r * 16 + r,g*16+g,b*16+b)
	| 6 ->
		(int ("0x" + String.sub h 0 2), int ("0x" + String.sub h 2 2), int ("0x" + String.sub h 4 2))
	| _ ->
		throw Error("Invalid '" + "#" + h + "'", p);
	}
}
// Assumes r, g, and b are contained in the set [0, 255]
function rgb2hsl(ir: int, ig: int, ib: int) {
	var r = ir / 255.
	var g = ig / 255.
	var b = ib / 255.
	var max = max(max(r, g), b);
	var min = min(min(r, g), b);
	var l = (max + min) / 2.;
	if (max == min) then
		(0., 0., l)
	else {
		var d = max - min;
		var s = if l > 0.5 then d / (2 - max - min) else d / (max + min);

		var h = if max == r then
			(g - b) / d + (if g < b then 6. else 0.)
		else if max == g then
			(b - r) / d + 2.
		else
			(r - g) / d + 4.;
		(h/6., s, l)
	}
}

function hue2rgb(p: float, q:float, t: float) {
	var t = if t < 0. then t + 1. else (if t > 1. then t - 1. else t)
	if t < 1/6. then
		p + (q - p) * 6. * t
	else if t < 1/2. then
		q
	else if t < 2/3. then
		p + (q - p) * (2/3. - t) * 6.
	else
		p
}

function hsl2rgb(h:float, s:float, l:float) {
	if (s <= 0.) then {
		var r = Math.round((max 0. (min 1. l)) * 255);
		(r, r, r)
	} else {
		var s = min 1.0 s;
		var h = max 0. (min 1. h);
		var l = max 0. (min 1. l);
		var q = if l < 0.5 then l * (1. + s) else l + s - l * s;
		var p = 2. * l - q;
		var r = hue2rgb(p, q, h + 1/3.);
		var g = hue2rgb(p, q, h);
		var b = hue2rgb(p, q, h - 1/3.);
		(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255))
	}
}

// Path
var file_full_path: string -> string = neko("$loader.loadprim('std@file_full_path',1)");

function is_abs_path(s) {
	match String.length s {
	| 0 -> false
	| 1 -> '/' == String.get(s, 0)
	| _ -> ':' == String.get(s, 1) || '/' == String.get(s, 0)
	}
}

type path {
	dir : string; // without trailing slash
	name: string;
	ext : string;
	full: string;
	str : string; // relative to root
}

var path_imports: path list ref = &[];

function path_reset() path_imports := []

function path_add(path) {
	function rec loop(l, file) match l {
	| [] -> false
	| path::tl -> if file == Sys.without_extension(path.full) then true else loop tl file
	}
	var exists = loop (*path_imports) Sys.without_extension(path.full);
	if (!exists) then path_imports := path::(*path_imports);
	!exists
}

function path_find(str) {
	function rec loop(l) match l {
	| [] -> throw Not_found
	| path::tl -> if path.str == str then path else loop tl
	}
	loop(*path_imports)
}

function path(s: string, def_ext: string) {
	function last_char(s, c) {
		function rec loop(i) match i {
		| -1 -> i
		| _ -> if String.get(s, i) == c then i else loop(i - 1)
		}
		loop((String.length s) - 1)
	}
	var last = (String.length s) - 1
	var c1, c2 = (last_char s '/', last_char s '\\')
	var dir, name = if c1 < c2 then
		(String.sub(s, 0, c2), String.sub(s, c2 + 1, last - c2))
	else if c2 < c1 then
		(String.sub(s, 0, c1), String.sub(s, c1 + 1, last - c1))
	else
		("", s)
	var pi = last_char name '.'
	var ext, name, s = if pi != -1 then
		(String.sub(name, pi + 1, (String.length name) - 1 - pi), String.sub(name, 0, pi), s)
	else
		(def_ext, name, if def_ext == "" then s else s + "." + def_ext)
	var ret = {
		dir  = dir;
		name = name;
		ext  = ext;
		full = file_full_path s;
		str  = (if dir == "" then name else dir + "/" + name) + (if ext == "" then "" else "." + ext);
	}
	(ret, path_add ret)
}

var base64_encode_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base_encode : string -> string -> string = neko "$loader.loadprim('std@base_encode',2)";

function img_to_base64(path: string, p: Lexer.pos): string {
	if String.sub(path, 0, 4) == "http" then throw Error("Local Files only", p);
	var parent: path = path_find(Lexer.source p);
	var path = if (parent.dir == "" || is_abs_path path) then path else parent.dir + "/" + path;
	var content = try IO.file_contents(path) catch { _ -> throw Error("file error: " + path, p) }
	var content_len = String.length content;
	var extra = content_len % 3;
	var size: int = ((content_len + 2) / 3) << 2;
	if size > 32768 then {                        // 32K
		throw Error("Image exceeds 24KB: " + path, p)
	}
	var sign = ord(String.get content 0) + (ord(String.get content 1) << 8)
	var ext = match sign {
	| 0xD8FF -> "jpg"
	| 0x5089 -> "png"
	| 0x4947 -> "gif"
	| _ -> match (Sys.extension path) {
		| "svg" -> "svg+xml"
		| _ -> throw Error("UnSupported " + "Type: " + path, p)
		}
	}
	var prefix = "data:image/" + ext + ";base64,"
	var prefix_len = String.length prefix
	var len = prefix_len + size
	var out = String.create len;
	String.blit(out, 0, prefix, 0, prefix_len);
	var extra = match extra {
	| 2 -> String.set(out, len - 1, '='); 1
	| 1 -> String.set(out, len - 1, '='); String.set(out, len - 2, '='); 2
	| _ -> extra                                  // 0
	}
	String.blit(out, prefix_len, base_encode(content, base64_encode_table), 0, size - extra);
	out
}

type sourcemap_value {
	MVer : int;
	MString : string;
	MBuffer : (string, int);
	MList : string list;
}
function sourcemap_write(ch, outfile, mappings, len) {
	function rec comma_sep(ch, l) match l {
	| [] ->
	| s::l ->
		IO.printf ch "\"%s\"" s;
		if l != [] then {
			IO.write_char ch ',';
			comma_sep ch l
		}
	}
	function rec loop(ch, l) match l {
	| [] ->
	| (k,v) :: l ->
		IO.printf ch "\"%s\":" k;
		match v {
		| MVer i         -> IO.printf ch "%d" i;
		| MString s      -> IO.write_char ch '"';  IO.write ch s;   IO.write_char ch '"';
		| MBuffer(s,len) -> IO.write_char ch '"';  ignore IO.output(ch, s, 0, len); IO.write_char ch '"';
		| MList vl       -> IO.write_char ch '[';  comma_sep ch vl; IO.write_char ch ']';
		}
		if l != [] then {
			IO.write_char ch ',';
			loop ch l
		}
	}
	var root = Sys.get_cwd();
	var root = "file://" + (if String.get(root, 0) == '/' then "" else "/") + String.concat("/", String.split(root,"\\"));
	var data = [
		("version", MVer 3);
		("file", MString Sys.without_dir(outfile));
		("sourceRoot", MString root);
		("sources", MList List.map(function(path) path.str, *path_imports));
		("mappings", MBuffer(mappings, len));
		("names", MList []);
	];
	IO.write_char ch '{';
	loop ch data;
	IO.write_char ch '}';
}
