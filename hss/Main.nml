/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Hss.Ast;
open Hss.Rules;

exception Error : (string, pos) list;

type context {
	defines: (string, value) Map.t;
	mutable vars : (string,value) Map.t;
	mutable blocks : (string,expr list) Map.t;
	mutable eval_rec : int;
	mutable skip_calc: int; // 0: no skip, 1: skip "/", 2 : skip ALL
	mutable ns : string option;
	mutable curblock : class option;
}

function error(msg,p) {
	throw Error([(msg,p)])
}

function warning(msg,p) {
	IO.printf IO.stderr "%s:%d: %s\n" (Lexer.source p,Lexer.line p,msg);
}

function print_sep(str,f,ch,l) {
	match l {
	| [] ->
	| e::tl ->
		f ch e;
		List.iter (function(e){IO.write ch str; f ch e}) tl
	}
}

function rec print_value(ch,v) {
	match fst v {
	| VIdent i -> IO.write ch i
	| VString s -> IO.printf ch "\"%s\"" (String.unescape s)
	| VUnit (v,u) -> IO.printf ch "%f%s" (v,u);
	| VFloat f -> IO.printf ch "%f" f;
	| VInt i -> IO.printf ch "%d" i;
	| VHex s -> IO.printf ch "#%s" s;
	| VBind (n,v) ->
		IO.printf ch "%s=" n;
		print_value ch v
	| VList l ->
		print_sep ", " print_value ch l
	| VGroup l ->
		print_sep " " print_value ch l
	| VUrl url ->
		IO.printf ch "url(\"%s\")" (String.unescape url)
	| VVar s ->
		IO.printf ch "$%s" s
	| VCall ((VIdent "CSS",_),[(VString str,_)]) ->
		IO.printf ch "%s" str
	| VCall (v,vl) ->
		print_value ch v;
		IO.write ch "(";
		print_sep "," print_value ch vl;
		IO.write ch ")";
	| VLabel ("dup",v) ->
		print_value ch v;
	| VLabel (l,v) ->
		print_value ch v;
		IO.printf ch " !%s" l;
	| VParentheses v ->
		IO.write ch "(";
		print_value ch v;
		IO.write ch ")";
	| VOp (op,v1,v2) ->
		print_value ch v1;
		IO.printf ch " %s " (Hss.Ast.s_op op);
		print_value ch v2;
	}
}

var r_ident = Regexp.build("^[a-zA-Z_][-a-zA-Z0-9_]*$");

function att_op_str(op) {
	function quote(v) if Regexp.find r_ident v 0 (String.length v) then v else "\""+v+"\"";
	match op {
	| AExists -> ""
	| AEqual v -> "="+quote(v)
	| AContain v -> "~="+quote(v)
	| ADash v -> "|="+quote(v)
	| ABegin v -> "^="+quote(v)
	| AEnd v -> "$="+quote(v)
	| ASubstr v -> "*="+quote(v)
	}
}

function rec print_class(first,ch,c) {
	if !first then
		IO.write ch (match c.operator {
		| OpDefault -> " "
		| OpChild -> " > "
		| OpPreceding imm -> if imm then " + " else " ~ "
		| OpJoint -> ""
		})
	match c.node {
	| None -> ()
	| Some id -> IO.write ch id;
	}
	List.iter (function((att,op)) {
		IO.printf ch "[%s%s]" (att,att_op_str op)
	}) c.attributes;
	match c.id {
	| None -> ()
	| Some id -> IO.printf ch "#%s" id;
	}
	List.iter (IO.printf ch ".%s") c.classes;
	List.iter (function(sel){
		match sel {
		| PSelector s -> IO.printf ch ":%s" s;
		| PSelector2 s -> IO.printf ch "::%s" s;
		| PSelectorCall(s, args) -> IO.printf ch ":%s(%s)" (s, args)
		}
	}) (List.rev c.selector);
	match c.sub {
	| None -> ()
	| Some cs ->
		print_class false ch cs;
	}
}

function rec print_media(ch, sp, e) {
	var t = fst e;
	if t != MComma then IO.write ch sp;
	match t {
	| MComma -> IO.write_char ch ',';
	| MNot   -> IO.write ch "not"
	| MOnly  -> IO.write ch "only"
	| MAnd   -> IO.write ch "and"
	| MType s | MQuotes s -> IO.write ch s;
	| MSigAttr s       -> IO.write_char ch '('; IO.write ch s; IO.write_char ch ')';
	| MAttr(s, val)    -> IO.write_char ch '('; IO.write ch s; IO.write_char ch ':';
		IO.write_char ch ' ';
		match fst val {
		| VString s | VIdent s -> IO.write ch s;
		| _ -> print_value ch val;
		}
		IO.write_char ch ')';
	| MParent x::tl ->
		IO.write_char ch '(';
		print_media ch "" x;
		List.iter (print_media ch " ") tl;
		IO.write_char ch ')';
	| MParent [] ->
	}
}

function rec print_css(ch,tabs,e) {
	match fst e {
	| EVar(name,val) ->
		IO.printf ch "%svar %s = " (tabs,name);
		print_value ch val;
		IO.write ch ";\n";
	| EVarBlock (name,el) ->
		IO.printf ch "%svar %s = {\n" (tabs,name);
		List.iter (print_css ch (tabs+"\t")) el;
		IO.printf ch "%s}\n" tabs;
	| EAttribute(name,val) ->
		IO.printf ch "%s%s: " (tabs,name);
		print_value ch val;
		IO.write ch ";\n";
	| EBlock(classes,el) ->
		IO.write ch tabs;
		print_sep ", " (print_class true) ch classes;
		IO.write ch " {\n";
		List.iter (print_css ch (tabs+"\t")) el;
		IO.printf ch "%s}\n" tabs;
	| EUseBlock(name, pl) ->
		match pl {
		| [] ->
			IO.printf ch "%s$%s;\n" (tabs,name)
		| _ ->
			IO.printf ch "%s$%s(" (tabs,name);
			print_sep "; " (print_value) ch pl;
			IO.write ch ");\n";
		}
	| EIfDefine _ -> // no output
	| ESub el ->
		List.iter (print_css ch tabs) el
	| EMedia (v,el) ->
		match el {
		| [] ->
		| _ ->
			IO.write ch "@media";
			List.iter (print_media ch " ") v;
			IO.write ch " {\n";
			List.iter (print_css ch (tabs+"\t")) el;
			IO.printf ch "%s}\n" tabs;
		}
	| EInclude s ->
		IO.write ch tabs;
		IO.write ch s;
		IO.write ch "\n";
	| EImport v ->
		var s = match fst v {
		| VString s -> s
		| _ -> error("String value require for " + "@import" + "("+ (s_value v) +")", pos v)
		}
		try IO.write ch IO.file_contents(s) catch { _ -> error("file error: " + s, snd e) }
		IO.write ch "\n";
	| EKeyframes (name, ks) ->
		IO.printf ch "%s@keyframes %s {\n" (tabs,name);
		List.iter (print_keyframe ch (tabs+"\t")) ks;
		IO.printf ch "%s}\n" tabs;
	}
}

function rec print_keyframe(ch, tabs, k) {
	IO.write ch tabs;
	match fst (fst k) {
	| VIdent i -> IO.write ch i;
	| VUnit(f, _) -> IO.write ch (f + "%")
	| _->
	}
	IO.write ch " {\n";
	List.iter print_css(ch, tabs+"\t") (snd k);
	IO.write ch tabs;
	IO.write ch "}\n";
}

function rec make_sub(p,c) {
	{
		node = p.node;
		id = p.id;
		classes = p.classes;
		selector = p.selector;
		attributes = p.attributes;
		operator = p.operator;
		sub = match p.sub {
			| None -> Some c
			| Some p -> Some (make_sub p c)
		};
	}
}

function rec flatten_subs(acc,e) {
	match fst e {
	| EAttribute _ -> e :: acc
	| ESub el -> List.fold flatten_subs acc el
	| _ -> acc
	}
}

function rec flatten(parents,e) {
	match fst e {
	| EVar _ | EAttribute _ | EUseBlock _ | EIfDefine _ | EVarBlock _ -> []
	| ESub el ->
		List.concat (List.map (flatten parents) el)
	| EBlock (classes,el) ->
		var classes = match parents {
			| [] -> classes
			| l -> List.concat (List.map (function(p) List.map (make_sub p) classes) parents)
		}
		var attribs = List.rev (List.fold flatten_subs [] el);
		var el = List.concat (List.map (flatten classes) el);
		match attribs {
		| [] -> el
		| _ -> (EBlock classes attribs,snd e) :: el
		}
	| EMedia (str,el) ->
		var attribs = List.rev (List.fold flatten_subs [] el);
		var el = List.concat (List.map (flatten parents) el);
		var el = match (parents,attribs) {
		| (_::_, _::_) -> (EBlock parents attribs,snd e) :: el
		| _ -> el
		}
		[(EMedia(str, el),snd e)]
	| EInclude s ->
		var s = match parents {
			| [] -> s
			| l ->
				var ch, out = IO.write_string();
				List.iter (function(c) { print_class true ch c; IO.write ch " "; }) l;
				out() + s
		}
		[(EInclude s,snd e)]
	| EImport _ | EKeyframes _ ->
		[e]
	}
}

function rec check_inherit(v) {
	match (fst v) {
	| VLabel (_,v) -> check_inherit v
	| VIdent n -> n == "inherit" || n == "initial" || n == "unset"
	| _ -> false
	}
}

function fractional_part(f) { if (Math.abs f) % 1 < 0.00001 then false else true }

function rec check_rule(r, v) { check_rule_inner(&[], r, v) }

function rec check_rule_inner(rest, r, v) {
	function rec check_rule(r,v) {check_rule_inner rest r v}
	match (r, fst v) {
	| (RId s, VIdent n) -> s == n
	| (RHex n, VHex s) -> String.length s == n
	| (RUnit s, VUnit(_,n)) -> s == n
	| (RCall(r,p), VCall (c,vl)) -> check_rule r c && check_rule p (VList vl,snd v)
	| (RFloat, VInt _) | (RFloat, VFloat _) -> true
	| (RInt, VInt _) -> true
	| (RInt, VFloat f) when !(fractional_part f) -> true
	| (RFloatRange(min,max), VInt n) -> n * 1.0 >= min && n * 1.0 <= max
	| (RFloatRange(min,max), VFloat n) -> n >= min && n <= max
	| (RIntRange(min,max), VInt n) -> n >= min && n <= max
	| (RIntRange(min,max), VFloat f) when !(fractional_part f) -> (Math.floor f) >= min && (Math.floor f) <= max
	| (ROr rl,_) -> List.exists (function(r) check_rule r v) rl
	| (RIdent, VIdent _) -> true
	| (RString, VString _) -> true
	| (_,VLabel (_,v)) -> check_rule r v
	| (RMany r, VList vl) -> List.all (check_rule r) vl
	| (RMany r, _) -> check_rule r v
	| (RGroup rl, _) ->
		function rec loop(rl, vl) match (rl, vl) {
		| ([], _) -> true
		| (r :: rl, v :: vl) ->
			rest := vl;
			if (check_rule r v) then loop rl (*rest) else false
		| _ -> false
		}
		match (fst v) {
		| VGroup vl -> (loop rl vl) && (*rest == [])
		| VList _ -> false
		| _ -> loop rl (v::*rest)
		}
	| (RGroupOpt rl, _) ->
		function rec loop(rl, vl) match (rl, vl) {
		| ([], _) | (_ ,[]) -> true
		| (r :: rl, v :: vl) ->
			rest := vl;
			if !(check_rule r v) then rest := v :: vl;
			loop rl (*rest)
		| _ -> false
		}
		match (fst v) {
		| VGroup vl -> (loop rl vl) && (*rest == [])
		| VList _ -> false
		| _ -> loop(rl, v::*rest) && (*rest == [] || v !== List.hd(*rest)) // Match at least one value
		}
	| (RGroupCustom rl, _) ->
		var used = &[];
		function rec loop(rl, vl) match vl {
		| [] -> List.none (function(r) match (snd r) {| ONormal -> true | _ -> false}) rl
		| v :: vl ->
			rest := vl
			var ok = &false
			var prev = &vl
			function rec filter(rl, v) match rl {
			| [] -> rl
			| r :: rl ->
				ok := check_rule (fst r) v
				if (*ok) then {
					prev := *rest;
					match (snd r) {
					| OMany -> (used := r :: *used); r :: rl
					| _ -> rl
					}
				} else {
					rest := *prev;
					match (snd r) {
					| OMany when List.exists(function(x) x === r, *used) -> (filter rl v)
					| _ -> r :: (filter rl v)
					}
				}
			}
			var rl = filter rl v;
			if (*ok) then loop rl (*rest) else {rest := v::*rest; loop rl []} // goto List.none
		}
		match (fst v) {
		| VGroup vl -> (loop rl vl) && (*rest == [])
		| VList _ -> false
		| _ -> loop(rl, v::*rest) && (*rest == [] || v !== List.hd(*rest))
		}
	| (RList rl, VList vl) ->
		function rec loop(rl, vl) match(rl, vl) {
		| ([], []) -> true
		| (r :: rl, v :: vl) -> (check_rule r v) && (loop rl vl)
		| _ -> false
		}
		loop rl vl
	| (RListCustom rl, VList vl) ->
		function rec loop(rl,vl) {
			match (rl,vl) {
			| ([], []) -> true
			| ((r,m) :: rl, v :: vl) ->
				var ok = check_rule r v;
				match m {
				| ONormal -> if ok then loop rl vl else false
				| OOpt -> if ok then loop rl vl else loop rl (v :: vl)
				| OMany -> if ok then loop ((r,m) :: rl) vl else loop rl (v :: vl)
				}
			| ((_,m) :: rl,[]) ->
				match m {
				| ONormal -> false
				| OOpt | OMany -> loop rl vl
				}
			| ([],_) ->
				false
			}
		}
		loop rl vl
	| (ROp ((s,r1,r2)::_,m), VOp(o,v1,v2)) ->
		match m {
		| ONormal -> // ratio: e.g: font: 16px/1.2 consolas
			function rec loop(r, v) match (fst v) {
			| VOp _ -> false
			| _ -> check_rule r v
			}
			Hss.Ast.s_op o == s && loop r1 v1 && loop r2 v2
		| _  -> true // TODO: for "grid-area", the Parser cannot correctly recognize the value such as "span 2 / span 3"
		             // TODO: "calc(expr)" is hard to check
		}
	| (RBind (s,r), VBind (n,v)) when s == n ->
		check_rule r v
	| _ -> false
	}
}

var hrules = {
	var h = Hashtbl.create();
	List.iter (function((a,b)) Hashtbl.add h a b) Hss.Rules.rules;
	h
}

function get_rule(ctx,name) {
	try
		Hashtbl.find hrules name
	catch {
	| Not_found ->
		match (name,ctx.curblock) {
		| ("src",Some { node = Some "@font-face" }) -> [Hss.Rules.font_face_src]
		| ("content", Some {selector = (PSelector s)::_}) | ("content", Some {selector = (PSelector2 s) ::_})
			when s == "before" || s == "after" -> Hss.Rules.pseudo_content
		| _ -> throw Not_found
		}
	}
}

function custom_calls(id, vl, p, vcall) {
	function exit() { throw Exit }
	function cint(i, p) { if (i < 0 || i > 255) then error("Unexpected " + i, p); i }
	function mix(ds, dl) {
		var r, g, b, i = (match vl {
		| [(VHex h, p); (VUnit(i,"%"),_)] ->
			var r, g, b = Hss.Utils.ofhex h p;
			(r, g, b, i)
		| [(VCall((VIdent "rgb",_),[(VInt r,rp);(VInt g,gp);(VInt b,bp)]),_); (VUnit(i,"%"),_)] ->
			(cint r rp, cint g gp, cint b bp, i)
		| _ ->
			exit()
		})
		var h, s, l = Hss.Utils.rgb2hsl r g b
		var r, g, b = Hss.Utils.hsl2rgb h (i * ds + s) (i * dl + l);
		VHex (sprintf "%.6X" ((r << 16) + (g << 8) + b))
	}
	(match id {
	| "lighten" ->    mix( 0.  ,  0.01)
	| "darken" ->     mix( 0.  , -0.01)
	| "saturate" ->   mix( 0.01,  0.  )
	| "desaturate" -> mix(-0.01,  0.  )
	| "invert" ->
		var r, g, b = (match vl {
		| [(VHex h, p)] -> Hss.Utils.ofhex h p
		| [(VCall((VIdent "rgb",_),[(VInt r,rp);(VInt g,gp);(VInt b,bp)]),_)] -> (cint r rp, cint g gp, cint b bp)
		| _ -> exit()
		})
		var r, g, b = (255 - r, 255 - g, 255 - b);
		VHex (sprintf "%.6X" ((r << 16) + (g << 8) + b))
	| "int" ->
		match vl {
		| [(VFloat f, _)] -> VInt Math.floor(f)
		| [(VUnit (f,u), _)] -> VUnit Math.ffloor(f) u
		| _ -> exit()
		}
	| _ -> vcall
	}, p)
}

function rec eval(ctx,v) {
	match fst v {
	| VIdent _
	| VString _
	| VUnit _
	| VUrl _
	| VInt _
	| VFloat _
	| VHex _ -> v
	| VList vl ->
		function rec loop(vl) match vl {
		| [] -> vl
		| v :: tl ->
			var v = eval ctx v;
			match fst v {
			| VList l -> List.append (loop l) (loop tl)
			| _ -> v :: loop tl
			}
		}
		(VList (loop vl),snd v)
	| VGroup vl ->
		(VGroup (List.map (eval ctx) vl),snd v)
	| VVar name ->
		if ctx.eval_rec > 100 then error "Invalid loop in variable expension" snd(v);
		var val = (try Map.find ctx.vars name catch { Not_found -> error ("Variable not declared '" + name + "'") snd(v) });
		ctx.eval_rec := ctx.eval_rec + 1;
		var r = eval ctx val;
		ctx.eval_rec := ctx.eval_rec - 1;
		r
	| VCall(i,vl) ->
		var i = eval ctx i;
		var id = match (fst i) { | VIdent n -> n | _ -> "" }
		var prev = ctx.skip_calc;
		ctx.skip_calc := if (id == "calc") then 2 else 0;
		var vl = List.map (eval ctx) vl;
		ctx.skip_calc := prev;
		var vcall = VCall i vl;
		try custom_calls(id, vl, pos v, vcall) catch { Exit -> (vcall, pos v) }
	| VLabel (l,v1) ->
		(VLabel l (eval ctx v1), snd v)
	| VBind(name,v1) ->
		(VBind name (eval ctx v1), snd v)
	| VParentheses e ->
		if ctx.skip_calc == 2 then // keep "()" for CSS "calc(expr)"
			(VParentheses (eval ctx e), snd v)
		else {
			var prev = ctx.skip_calc;
			ctx.skip_calc := 0;
			var v = eval ctx e;
			ctx.skip_calc := prev;
			v
		}
	| VOp (op,v1,v2) ->
		var v1 = eval ctx v1;
		var v2 = eval ctx v2;
		function fop (x:float,y:float) {
			match op {
			| Add -> x + y
			| Sub -> x - y
			| Mul -> x * y
			| Div -> if y == 0. then error "Division by 0" snd(v) else x / y
			| And | Or | Xor | BoolOr | BoolAnd -> error ("UnSupported "+"Op: "+s_op op) snd(v)
			}
		};
		function rec loop(v1,v2) {
			match (fst v1,fst v2) {
			| (VInt x, VInt y) ->
				var f = fop(x * 1.0, y * 1.0);
				if (fractional_part f) then VFloat ( Math.fround(f * 1000.) / 1000. ) else VInt (Math.floor f)
			| (VInt x, VFloat y) -> VFloat (fop (x * 1.0) y)
			| (VFloat x, VInt y) -> VFloat (fop x (y * 1.0))
			| (VFloat x, VFloat y) -> VFloat (fop x y)
			| (VUnit (x,u), VUnit (y,u2)) when u == u2 -> VUnit (fop x y) u
			| (VUnit (x,u), VInt y) -> VUnit (fop x (y * 1.0)) u
			| (VUnit (x,u), VFloat y) -> VUnit (fop x y) u
			| (VInt x, VUnit (y,u)) -> VUnit (fop (x * 1.0) y) u
			| (VFloat x, VUnit (y,u)) -> VUnit (fop x y) u
			| (VHex c, VFloat a) ->
				// assume color operation
				function color(c:int) {
					var c = Math.round (fop (c * 1.0) a);
					if c < 0 then 0 else if c > 255 then 255 else c;
				}
				var r, g, b = Hss.Utils.ofhex(c, snd v1);
				var r, g, b = (color r, color g, color b);
				VHex (sprintf "%.6X" ((r << 16) or (g << 8) or b))
			| (_,VLabel (l,v)) ->
				VLabel l (loop v1 v, snd v)
			| _ ->
				error ("'" + (s_value v) + "' are not allowed") snd(v)
			}
		}
		if (op == Div && ctx.skip_calc == 1) || ctx.skip_calc == 2 then
			(VOp op v1 v2,snd v)
		else
			(loop v1 v2,snd v)
	}
}

function rec eval_block(ctx,b) {
	function add(r,v2) {
		r := fst (eval ctx (VOp Add (*r,snd v2) v2,snd v2))
	}
	function get_block_sizes(el) {
		var matched = Hashtbl.create();
		function set(k) {
			if Hashtbl.exists matched k then false else {
				Hashtbl.add matched k ();
				true;
			}
		}
		var lr = &(VInt 0);
		var tb = &(VInt 0);
		List.iter (function(e) {
			match fst e {
			| EAttribute (name,v) ->
				match name {
				| "padding-left" when set "pl" -> add lr v
				| "padding-right" when set "pr" -> add lr v
				| "padding-top" when set "pt" -> add tb v
				| "padding-bottom" when set "pb" -> add tb v
				| "padding" ->
					var t, r, b, l = match fst v {
					| VGroup [tb;rl] -> (tb, rl, tb, rl)
					| VGroup [t;rl;b] -> (t, rl, b, rl)
					| VGroup [t;r;b;l] -> (t, r, b, l)
					| _ -> (v, v, v, v)
					}
					if set "pl" then add lr l;
					if set "pr" then add lr r;
					if set "pt" then add tb t;
					if set "pb" then add tb b;
				| "border-left-width" when set "bl" -> add lr v
				| "border-right-width" when set "br" -> add lr v
				| "border-top-width" when set "bt" -> add tb v
				| "border-bottom-width" when set "bb" -> add tb v
				| "border" ->
					var v = match fst v {
						| VGroup (v :: _) -> v
						| _ -> v
					};
					if set "bl" then add lr v;
					if set "br" then add lr v;
					if set "bt" then add tb v;
					if set "bb" then add tb v;
				| _ -> ()
				}
			| _ -> ()
			}
		}) (List.rev el);
		(*lr, *tb)
	}
	match fst b {
	| EBlock (cl,el) ->
		var el = List.map (function(e) {
			match fst e {
			| EAttribute (name,val) ->
				var p = snd val;
				match name {
				| "hss-width" ->
					var w, _ = get_block_sizes el;
					(EAttribute("width", eval ctx (VOp(Sub,val,(w,p)),p)),p)
				| "hss-height" ->
					var _, h = get_block_sizes el;
					(EAttribute("height", eval ctx (VOp(Sub,val,(h,p)),p)),p)
				| _ -> e
				}
			| _ -> assert()
			}
		}) el;
		(EBlock cl el, snd b)
	| EMedia (ml,el) ->
		(EMedia ml (List.map (eval_block ctx) el), snd b)
	| _ ->
		b
	}
}

function rec expand_val(value) {
	var p = snd value;
	match fst value {
	| VCall((VIdent "rgba",_) as c,[(VHex h,hp);(VFloat f,fp)]) ->
		var r, g, b = Hss.Utils.ofhex h hp;
		var params = [(VInt r,hp);(VInt g,hp);(VInt b,hp);(VFloat f,fp)];
		expand_val (VCall c params, p)
	| VCall((VIdent "embed",p1), [(VString url, p2)]) ->
		(VCall (VIdent "url",p1) [(VString Hss.Utils.img_to_base64(url, p2), p2)], p)
	| VCall (v,vl) ->
		(VCall expand_val(v) (List.map expand_val vl), p)
	| VList vl ->
		(VList (List.map expand_val vl),p)
	| VGroup vl ->
		(VGroup (List.map expand_val vl),p)
	| VLabel (l,v) ->
		(VLabel l expand_val(v),p)
	| VBind (name,v) ->
		(VBind name expand_val(v),p)
	| VOp (op,v1,v2) ->
		(VOp op expand_val(v1) expand_val(v2),p)
	| VUnit(0., u) ->
		if (u == "s" || u == "ms" || u == "%") then value else (VInt 0, p)
	| _ ->
		value
	}
}


function rec expand_hacks(name,value,p) {
	var label = &None;
	var value = match fst value {
		| VLabel(l,v) -> label := Some (l,snd value); v;
		| _ -> value;
	}
	var value = expand_val value;
	var w = match name {
	| "background-color" | "color" | "background" ->
		var first = match fst value { VGroup v :: l -> v | _ -> value };
		match fst first {
		| VCall ((VIdent "rgba",_),[r;g;b;a]) ->
			var hcol = String.concat "" (List.map (function(c) {
				match fst c {
				| VInt i -> sprintf "%.2X" i
				| VUnit (f,"%") ->
					var i = Math.floor (f * 2.55);
					sprintf "%.2X" (if i < 0 then 0 else if i > 255 then 255 else i)
				| _ -> assert()
				}
			}) [r;g;b]);
			(ESub [
				(EAttribute name (VHex hcol,p),p); // simply adds a fallback with fixed hex color
				(EAttribute name value,p);
			],p)
		| _ ->
			(EAttribute name value,p)
		}
	| _ ->
		(EAttribute name value,p)
	}
	match *label {
	| None -> w
	| Some (label,p) ->
		function rec wrap(e) {
			(match fst e {
			| ESub el -> ESub (List.map wrap el)
			| EAttribute (name,v) -> EAttribute name (VLabel label v,p)
			| _ -> assert()
			},snd e)
		}
		wrap w
	}
}

function rec expand_ns(ns,c) {
	c.classes := List.map (function(c:string) ns + c) c.classes;
	match c.id {
	| None -> ()
	| Some id -> c.id := Some (ns + id)
	}
	match c.sub {
	| None -> ()
	| Some c -> expand_ns ns c
	}
}

function rec check_class(ctx,p,c) {
	List.iter (function(sel){
		match sel {
		| PSelector2 s -> if !(List.mem(s, selectors) || (snd Hss.Utils.vendor_prefix(s) != "")) then error ("Invalid '" + "::" + s + "'") p
		| _ -> () // No need to check. because it's generated by Lexer.
		}
	}) c.selector
	match c.sub {
	| None -> ()
	| Some c -> check_class ctx p c
	}
}

function rec find_subclass(c: class) {
	match c.sub {
	| Some sc -> find_subclass sc
	| None -> c
	}
}

function load_rules(find, name, value, p) {
	try {
		var rules = find name
		if !(List.exists (function(r) check_rule r value) rules) && !(check_inherit value) then {
			var buf, str = IO.write_string();
			print_value buf value;
			error ("Invalid '"+name+"' value '"+str()+"'") p;
		}
	} catch {
	| Not_found -> if snd(Hss.Utils.vendor_prefix name) == "" then error("Unknown attribute '"+name+"'",p)
	}
}

var media_hrules = {
	var h = Hashtbl.create();
	List.iter (function((a,b)) Hashtbl.add h a b) Hss.Rules.media_rules;
	h
}

function check_media(ctx, ml: media list) {
	function err (s, p) { error ("Unexpected " + s) p}
	// eval ,check rule, and check state in a loop
	function rec loop(l: media list, state: int) {
		// states:
		// MQuotes         : 0, Accept: [ALL]
		// MComma, (BEGIN) : 1, Accept: [3, 0]
		// MAnd            : 2, Accept: [3, 0]
		// MType           : 3, Accept: [NOT 3]
		// MSigAttr        : 3, Accept: [2, 1, 0]
		// MAttr           : 3, Accept: [2, 1, 0]
		// MParent         : 3, Accept: [2, 1, 0]
		// MNot, MOnly     : 4, Accept: [1, 0]
		match l {
		| [] -> l
		| (m,p) :: tl ->
			var state = match m {
			| MComma ->
				if (state == 3 || state == 0) then 1 else err(",", p);
			| MAnd ->
				if tl != [] && (state == 3 || state == 0) then 2 else err("and", p);
			| MNot | MOnly ->
				if tl != [] && state < 2 then 4 else err (if m == MNot then "not" else "only") p;
			| MType s ->
				if state !=3 then 3 else err(s, p);
			| MSigAttr s ->
				var b = match s {
				| "color" | "color-index" | "monochrome" -> true
				| _ -> false
				}
				if state < 3 && b then 3 else err("("+ s + ")", p);
			| MAttr(k, v) ->
				if state < 3 then 3 else err("("+ k + ": " + (s_value v) + ")", p);
			| MParent l ->
				if state < 3 && l != [] then 3 else err("(...)", p);
			| MQuotes _ ->
				0;
			}
			var mp = match m {
			| MAttr(k, v) ->
				var v = eval ctx v;
				match fst v {
				| VString _ -> () // skip check rule
				| _ -> load_rules(Hashtbl.find media_hrules, k, v, p)
				}
				(MAttr(k, v), p)
			| MParent l -> (MParent (loop l 1), p);
			| _ -> List.hd l      // (m,p)
			}
			mp :: (loop tl state)
		}
	}
	loop ml 1;
}

// simple detection only, cannot detect circular references
function selfref_var(id, v) {
	match fst v {
	| VVar name when id == name -> error("Self referencing loop: " + id + " = $" + id, pos v)
	| _ ->
	}
}

function rec selfref_block(redef, id, l) {
	match l {
	| [] ->
	| e::tl ->
		match fst e {
		| EUseBlock(name, _) ->
			if name == id && (*redef) == false then error("Self referencing loop: " + "$" + id, pos e);
		| EVarBlock(name, el) ->
			var r = *redef; (selfref_block redef id el); redef := r;
			if name == id && (*redef) == false then redef := true;
		| EBlock(_,el) ->
			var r = *redef; (selfref_block redef id el); redef := r;
		| _ ->
		}
		selfref_block redef id tl;
	}
}

function rec check(ctx,e) {
	match fst e {
	| EVar ("namespace",value) ->
		match fst value {
		| VString s -> ctx.ns := Some s;
		| _ -> error ("String value require for " + "namespace") snd(value);
		}
		e
	| EVar (name,value) ->
		selfref_var name value;
		ctx.vars := Map.add ctx.vars name value;
		e
	| EVarBlock (name,el) ->
		var redef = &false;
		selfref_block redef name el;
		ctx.blocks := Map.add ctx.blocks name el;
		e
	| EBlock (classes,el) ->
		match ctx.ns {
		| None -> ()
		| Some ns -> List.iter (expand_ns ns) classes
		}
		var old = (ctx.vars,ctx.blocks);
		var old2 = (ctx.ns, ctx.curblock);
		ctx.curblock := match classes { a::_ -> Some(find_subclass a) | _ -> None };
		var el = List.map (check ctx) el;
		List.iter (check_class ctx snd(e)) classes;
		// check duplicate variables
		ignore(List.fold (function(acc,e) {
			match fst e {
			| EAttribute(name,v) ->
				match fst v {
				| VCall ((VIdent "CSS",_),_) | VLabel ("dup",_) ->
					acc
				| _ ->
					try {
						var v2 = Map.find acc name;
						if !(List.mem name Hss.Rules.allow_duplicate_attributes) then warning ("Warning, duplicate attribute '"+name+"'") snd(e);
					} catch {
						Not_found -> ()
					}
					Map.add acc name v
				}
			| ESub _ -> acc // don't take into account sub-blocks (rgba)
			| _ -> acc
			}
		}) Map.empty() el);
		ctx.vars := fst old;
		ctx.blocks := snd old;
		ctx.ns := fst old2;
		ctx.curblock := snd old2;
		(EBlock classes el,snd e)
	| EAttribute (name,value) ->
		var value = eval ctx value;
		match value {
		| (VCall ((VIdent "CSS",_),[(VString _,_)]),_) -> e
		| _ ->
			var p = pos e;
			load_rules(get_rule ctx, name, value, p);
			expand_hacks(name, value, p)
		}
	| EUseBlock(name, pl) ->
		var p = pos e;
		var b = try Map.find ctx.blocks name catch { Not_found -> error ("Variable not declared '" + name + "'") p };
		var old_ns, old_vars, old_blocks = (ctx.ns, ctx.vars, ctx.blocks);
		List.iter (function(v){
			match fst v {
			| VBind(name, value) ->
				selfref_var name value;
				ctx.vars := Map.add ctx.vars name value;
			| _ ->
			}
		}) pl;
		var no = (String.get name 0) != '_';
		try {
			if no then {
				var b = List.map (check ctx) b;
				ctx.ns := old_ns;
				ctx.vars := old_vars;
				ctx.blocks := old_blocks;
				(ESub b, p)
			} else {
				var locals = &Map.empty();
				var b = List.map (function(e){
					match fst e {
					| EVar (name,value) when name != "namespace" ->
						selfref_var name value;
						locals := Map.add (*locals) name value;
					| _ ->
					}
					check ctx e;
				}) b;
				ctx.vars := old_vars;
				Map.iter (function(name, value) ctx.vars := Map.add ctx.vars name value) (*locals);
				(ESub b, p)
			}
		} catch {
		| Error l -> throw Error(("Included here ",p)::l)
		}
	| EIfDefine((name, t), b) ->
		function rec loop(name, t, b, pr, pt) {
			var r = match (pr, pt) {
			| (true, false) -> true  //  ( true, ||)
			| (false, true) -> false //  (false, &&)
			| _ -> Map.exists ctx.defines name || Map.exists ctx.vars name;
			}
			match fst b {
			| EIfDefine ((name, t2), b) -> loop name t2 b r t
			| _ ->
				var next = if t then r else !r;
				if next then check ctx b else (ESub [], pos b)
			}
		}
		loop name t b true true;
	| ESub el ->
		(ESub (List.map (check ctx) el),snd e)
	| EMedia (l,el) ->
		(EMedia (check_media ctx l) (List.map (check ctx) el), snd e)
	| EInclude _ ->
		e
	| EImport v ->
		var ev = eval ctx v;
		var s = match fst ev {
		| VString s -> s
		| _ -> error("String value require for " + "@import" + "("+ (s_value v) +")", pos v)
		}
		var p = pos e;
		if ctx.curblock != None then error("only" + " allowed at the top level: " + "@import", p)
		var parent = Hss.Utils.path_find(Lexer.source p);
		var file = if Hss.Utils.is_abs_path(s) then s else (if parent.dir == "" then s else parent.dir + "/" + s);
		var path = Hss.Utils.path(file, "hss", false);
		if !Hss.Utils.path_duplicate(path) then {
			Hss.Utils.path_add(path);
			match path.ext {
			| "hss"	->
				var ch = try (IO.read_file path.full true) catch {
				| _ -> error("file error: " + (Hss.Utils.path_str path), p)
				}
				var lex = Lexer.create Buffer.create();
				Lexer.input lex path.full ch 1 0;
				var el = Hss.Parser.parse lex;
				IO.close_in ch;
				var no = (String.get path.name 0) != '_';
				var old_ns, old_vars, old_blocks = (ctx.ns, ctx.vars, ctx.blocks)
				var el = List.map (check ctx) el;
				if no then {
					ctx.ns := old_ns;
					ctx.vars := old_vars;
					ctx.blocks := old_blocks;
				}
				(ESub el, p)
			| "css" ->
				(EImport (VString file, pos v), p)
			| _ ->
				error("UnSupported " + "Type: " + "." + path.ext, p)
			}
		} else {
			(ESub [], p) // duplicate, simply ignore it;
		}
	| EKeyframes (name, sl) ->
		if ctx.curblock != None then error("only" + " allowed at the top level: " + "@keyframes", pos e)
		function rec loop(l) match l {
		| [] -> l
		| seg :: l -> match fst seg {
			| (VIdent i,p) -> if !(i == "from" || i == "to") then error("Unexpected " + i, p)
			| (VUnit (f, u),p) -> if (f < 0. || f > 100.) then error("Unexpected " + f + u, p)
			| _ -> // never run to here since Parser
			}
			var attribs = List.rev List.fold(flatten_subs, [], snd seg); // only attributes
			(fst seg, List.map(check ctx, attribs)) :: loop l
		}
		(EKeyframes(name, loop sl), pos e)
	}
}

function parse_defs(defs, arg) {
	function ident(s) Regexp.find r_ident s 0 (String.length s);
	var null_pos = Lexer.null_pos;
	var a = String.split arg "=";
	var name, value = match a {
	| [i] when (ident i) -> (i, VString "1")
	| [i; s] when (ident i) ->
		(i, match (String.get s 0) {
		| '#' ->
			var r, g, b = HSS.Utils.ofhex String.sub(s, 1, (String.length s) - 1) null_pos;
			VHex (sprintf "%.6X" ((r << 16) + (g << 8) + b))
		| '0' when (String.get s 1) == 'x' -> VInt int(s)
		| _ ->  VString s
		})
	| _ -> error ("Unexpected " + "-D" + arg) null_pos
	}
	defs := Map.add (*defs) name (value, null_pos)
}

function display(msg,p) {
	if p == Lexer.null_pos then	{
		Stack.dump IO.stderr Stack.exc();
		IO.printf IO.stderr "Exception : %s\n" msg
	} else
	IO.printf IO.stderr "%s:%d: %s\n" (Hss.Utils.relative_path(Lexer.source p),Lexer.line p,msg);
}

function report(msg,p) {
	display msg p;
	Sys.exit(-1);
}

try {
	var head = "HSS v1.6 - (c)2008-2019 Nicolas Cannasse\nUsage : hss [options] <file>";
	var files = &[];
	var output = &None;
	var defs = &Map.empty();
	var decl = [
		("-output",Args.String (function(o) output := Some o),"<dir> : specify output directory");
	];
	Args.parse head decl (function(file) {
		var len = String.length file;
		if len >= 2 && String.sub(file, 0, 2) == "-D" then {
			parse_defs defs String.sub(file, 2, len-2)
		} else {
			files := file :: *files
		}
	});
	List.iter (function(file) {
		// parse
		var ch = IO.read_file file true;
		var lex = Lexer.create Buffer.create();
		var path = Hss.Utils.path file "" true;
		Lexer.input lex path.full ch 1 0;
		var el = Hss.Parser.parse lex;
		IO.close_in ch;
		// check + replace vars
		var ctx = { defines = *defs; vars = Map.empty(); blocks = Map.empty(); eval_rec = 0; skip_calc = 1; ns = None; curblock = None; };
		var el = List.map (check ctx) el;
		// flatten
		var el = List.concat (List.map flatten([]) el);
		// final eval
		var el = List.map eval_block(ctx) el;
		// write
		var file2 = Sys.without_extension file + ".css";
		var file2 = match *output { None -> file2 | Some dir -> dir + Sys.without_dir file2 };
		if file != file2 then {
			var ch = IO.write_file file2 true;
			List.iter (print_css ch "") el;
			IO.close_out ch;
		}
		Hss.Utils.path_reset()
	}) (*files);
} catch {
	// todo : fix a small bug in nekoml to have ctx.current not to lowercase
	// in order to get correct constructor hashing
	| Hss.Lexer.Error(msg,pos) -> report Hss.Lexer.error_msg(msg) pos
	| Hss.Parser.Error(msg,pos) -> report Hss.Parser.error_msg(msg) pos
	| Hss.Utils.Error(msg,pos) -> report msg pos
	| Error l -> List.iter (function((msg,p)) display msg p) List.rev(l); Sys.exit (-1);
	| e ->
		Stack.dump IO.stderr Stack.exc();
		IO.printf IO.stderr "Exception : %s\n" string(e);
		Sys.exit (-1);
}