/*
 *  Hss Format
 *  Copyright (c)2008 Nicolas Cannasse
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Hss.Ast;

type error_msg {
	Invalid_character : char;
	Unterminated_string;
	Invalid_escape;
	Unclosed_comment;
	Unclosed_parentheses;
}

exception Error : (error_msg , Lexer.pos)

type line_info {
	mutable file  : string;
	mutable lines : int array;
	mutable all : (string, int array) list;
	empty: int array;
}
var li = { file = ""; lines = Array.create(); all = []; empty = Array.create(); }

function line_inc(file, pos) {
	if file != li.file then {
		function rec loop(l) match l {
		| [] ->
			li.file  := file;
			li.lines := neko "var _a = $amake(512); _a[0] = 0; $array(_a,string, 1)"; // copy from Array.make
			li.all   := (li.file, li.lines) :: li.all
		| (s, a) :: _ when s == file ->
			li.file  := s;
			li.lines := a;
		| _ :: l -> loop l
		}
		loop li.all
	}
	Array.add li.lines pos
}

function column(p: pos):pos_column {
	var source = p.psource;
	var a = if source == li.file then li.lines else {
		function rec find(l) match l {
		| [] -> li.empty
		| (s, a) :: l ->
			if s == source then {
				li.file  := s;
				li.lines := a;
				a
			} else
				find l
		}
		find li.all
	}
	var len = Array.length a;
	if p.pline > 0 && p.pline <= len then {
		var start = a.[p.pline-1];
		var lnext = &p.pline;
		while *lnext < len && p.pmax >= a.[*lnext] {
			lnext := *lnext + 1
		}
		{lmin=p.pline; lmax=(*lnext); cmin=1 + p.pmin - start; cmax=1 + p.pmax - a.[*lnext-1]; cmax_on=1 + p.pmax - start;}
	} else
		{lmin=0; lmax=0; cmin=0; cmax=0; cmax_on=0;}
}

function error_msg(msg) {
	match msg {
	| Invalid_character c when ord c > 32 && ord c < 128 -> sprintf "Invalid character '%c'" c
	| Invalid_character c -> sprintf "Invalid character 0x%.2X" (ord c)
	| Invalid_escape -> "Invalid escaped char"
	| Unterminated_string -> "Unterminated string"
	| Unclosed_comment -> "Unclosed " + "comment"
	| Unclosed_parentheses -> "Unclosed " + ")"
	}
}

function error(l,msg) {
	throw Error(msg,Lexer.curpos l)
}

var keywords = {
	var h = Hashtbl.create();
	List.iter (function(k) { Hashtbl.add h (s_keyword k) k }) [Var;Media;Import;Keyframes;Include;PrIf;PrElse;PrElseIf;PrEnd];
	h
}

// similar to Lexer.char but there is no "inc_line" here
function peek_char(l: Buffer.t Lexer.t) : char {
	var c = Lexer.read l;
	l.bpos := l.bpos - 1;
	l.bin := l.bin + 1;
	c
}

function mk(l,t) {
	(t,Lexer.curpos l)
}

function mk_int(l) {
	mk l Const(Int(int (Lexer.current l)))
}

function mk_float(l) {
	mk l Const(Float(float (Lexer.current l)))
}

var ident = "[a-zA-Z_][-a-zA-Z0-9_]*";

var expr = &Lexer.empty();
var estring = &Lexer.empty();
var eqstring = &Lexer.empty();
var ecomment = &Lexer.empty();
var epuargs = &Lexer.empty();

function comment(l) {
	Lexer.token l (*ecomment)
}

function str(l) {
	Lexer.token l (*estring)
}

function qstr(l) {
	Lexer.token l (*eqstring)
}

function puargs(l) {
	Lexer.token l (*epuargs)
}

function next_token(l) {
	Lexer.token l (*expr)
}

function line_inc_with(next, l: Buffer.t Lexer.t) {
	line_inc(l.source, l.pos);
	next l
}

function pseudo_or_doubledot(l: Buffer.t Lexer.t) {
	var s = Lexer.current l;
	var len = (String.length s) - 1;
	var s = String.sub s 1 len;
	try
		match Map.find Hss.Rules.pseudo_cmap s {
		| 1 ->
			mk l (Selector s)
		| 2 when (peek_char l) == '(' ->
			var p1 = Lexer.curpos l;
			ignore (next_token l); // ignore "("
			var buf = Lexer.data l;
			Buffer.reset buf;
			try puargs l catch { Exit -> throw Error(Unclosed_parentheses, Lexer.curpos l) };
			(SelectorFn(s, Buffer.string buf), Lexer.punion(p1, Lexer.curpos l))
		| _ ->
			throw Not_found
		}
	catch {
	| Not_found -> // backtracing hack for (":"+ident)
		l.pos  := l.pos - len;
		l.bpos := l.bpos - len;
		l.cpos := l.bpos;
		l.bin  := l.bin + len;
		l.cin  := l.bin;
		l.current := ":";
		mk l DoubleDot
	}
}

expr := Lexer.build (List.concat [[
	("\239\187\191", next_token);
	(";", function(l) { mk l Semicolon });
	(".", function(l) { mk l Dot });
	(",", function(l) { mk l Comma });
	("{", function(l) { mk l BraceOpen });
	("}", function(l) { mk l BraceClose });
	("(", function(l) { mk l ParentOpen });
	(")", function(l) { mk l ParentClose });
	("\\[", function(l) { mk l BracketOpen });
	("]", function(l) { mk l BracketClose });
	(":"+ident, pseudo_or_doubledot);
	("::", function(l) { mk l DoubleDotx2 });
	(":", function(l) { mk l DoubleDot });
	("%", function(l) { mk l Percent });
	("!", function(l) { mk l Exclamation });
	("=", function(l) { mk l Eq });
	("~", function(l) { mk l Tild });
	("||", function(l) mk l Op(BoolOr));
	("|", function(l) mk l Op(Or));
	("&&", function(l) mk l Op(BoolAnd));
	("&", function(l) mk l Op(And));
	("^", function(l) mk l Op(Xor));
	("[ \r\t]+", next_token);
	("0", mk_int);
	("-?[1-9][0-9]*", mk_int);
	("-?[0-9]+.[0-9]*", mk_float);
	("-?.[0-9]+", mk_float);
	("\n", line_inc_with next_token);
	(ident, function(l) {
		var s = Lexer.current l;
		mk l (if s != "var" then Const (Ident s) else Keyword Var)
	});
	("[-@][-a-zA-Z_][-a-zA-Z0-9_]*", function(l) {
		var s = Lexer.current l;
		mk l (match neko("$sget(s,0)") {
		| '@' -> try Keyword (Hashtbl.find keywords s) catch { Not_found -> Const (Ident s) }
		| _ -> Const (Ident s)
		})
	});
	("$"+ident, function(l) {
		var i = Lexer.current(l);
		mk l Const(Val (String.sub i 1 (String.length i - 1)))
	});
	("$", function(l) mk l Dollar);
	("#", function(l) { mk l Sharp });
	(">", function(l) { mk l Gt });
	("\\+", function(l) { mk l Op(Add) } );
	("-", function(l) { mk l Op(Sub) } );
	("\\*", function(l) { mk l Op(Mul) } );
	("/", function(l) { mk l Op(Div) } );
	("\"", function(l) {
		var p1 = Lexer.curpos l;
		var buf = Lexer.data l;
		Buffer.reset buf;
		try str l catch { Exit -> throw Error(Unterminated_string,p1) };
		var p2 = Lexer.curpos l;
		(Const String(Buffer.string buf) , Lexer.punion p1 p2)
	});
	("'", function(l) {
		var p1 = Lexer.curpos l;
		var buf = Lexer.data l;
		Buffer.reset buf;
		try qstr l catch { Exit -> throw Error(Unterminated_string,p1) };
		var p2 = Lexer.curpos l;
		(Const String(Buffer.string buf) , Lexer.punion p1 p2)
	});
	("/\\*", function(l) {
		var p1 = Lexer.curpos l;
		var buf = Lexer.data l;
		Buffer.reset buf;
		try comment l catch { Exit -> throw Error(Unclosed_comment,p1) };
		var p2 = Lexer.curpos l;
		(Comment(Buffer.string buf) , Lexer.punion p1 p2)
	});
	("//[^\n]*", function(l) {
		var s = Lexer.current l;
		var len = String.length s;
		mk l CommentLine(String.sub s 2 (len - 2))
	});
]])
	(function(l) {
		match Lexer.char l {
		| None -> mk l Eof
		| Some c -> error l (Invalid_character c)
		}
	})
;

function exit(l) {}

function throw_exit(l) {throw Exit}

function buffer_add_with(next, l) { Buffer.add (Lexer.data l) (Lexer.current l); next l }

var comment_add = buffer_add_with comment;

ecomment := Lexer.build [
	("\n", line_inc_with comment_add);
	("\\*/", exit);
	("\\*", comment_add);
	("[^*\n]+", comment_add);
] throw_exit;

epuargs := Lexer.build [ // transform \n to ' ' for future sourcemap
	("\n", function(l:Buffer.t Lexer.t){ line_inc(l.source, l.pos); Buffer.add_char (Lexer.data l) ' '; puargs l});
	("\r", puargs);
	(")", exit);
	("[^)}{\n\r]+", buffer_add_with puargs);
] throw_exit;

function inc_with_escape(next, l:Buffer.t Lexer.t) {line_inc(l.source, l.pos); Buffer.add (Lexer.data l) "\\\\n"; next l}
function string_plus_slash(l) { Buffer.add_char (Lexer.data l) '\\'; Buffer.add (Lexer.data l) (Lexer.current l); str l }

estring := Lexer.build [
	("\n", inc_with_escape str);
	("\r", str);
	("\\\\\"", string_plus_slash);
	("\\\\" , string_plus_slash);
	("\"", exit);
	("[^\r\n\"\\\\]+", buffer_add_with str);
] throw_exit;

function qstring_plus_slash(l) { Buffer.add_char (Lexer.data l) '\\'; Buffer.add (Lexer.data l) (Lexer.current l); qstr l }

eqstring := Lexer.build [
	("\n", inc_with_escape qstr);
	("\r", qstr);
	("\\\\'", qstring_plus_slash);
	("\\\\" , qstring_plus_slash);
	("'", exit);
	("[^\r\n'\\\\]+", buffer_add_with qstr);
] throw_exit;
